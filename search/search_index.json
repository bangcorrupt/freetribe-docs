{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Freetribe is a free, open-source firmware for Electribe 2, built from the ground up using original code and open-source projects. Freetribe aims to provide a user-friendly API for connecting control input to audio processing.</p> <p>See Getting Started to jump right into the Freetribe API. See Features for an overview of what's included, or Architecture for a deeper look at the system.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>Freetribe would be almost impossible without other open-source projects. The CPU drivers are based on StarterWare by Texas Instruments. The hardware abstraction, build environment and code examples provided the stepping-stone needed to get started.</p> <p>In much the same way, the DSP drivers are based on monome/aleph. This showed how to initialise the Blackfin processor and configure peripherals. They also provide a public domain DSP library, with many of the difficult maths problems packaged into convenient unit generators.</p> <p>MIDI input parsing is based on mikromodular/libmidi, with sysex/binary conversion borrowed from the Arduino MIDI library by Francois Best.</p> <p>UGUI and micromenu provide a graphical interface for user applications.</p> <p>Special thanks to countless stackoverflow users.</p>"},{"location":"architecture/","title":"System Overview","text":"<p>This section takes a deeper look at the Freetribe system architecture.</p> <p>There are two separate firmwares, one for the ARM CPU and the other for the Blackfin DSP. The code is built in layers, from peripheral drivers up to user applications. Each layer consumes from the layer below and provides for the layer above.</p>"},{"location":"building/","title":"Building an Application","text":"<p>This section describes the build process.</p>"},{"location":"building/#building-locally","title":"Building Locally","text":""},{"location":"building/#building-with-docker","title":"Building with Docker","text":"<p>We can run <code>make</code> in the container to build Freetribe.</p> <pre><code>docker compose exec freetribe make clean\ndocker compose exec freetribe make\n</code></pre> <p>The final binary will be at <code>freetribe/cpu/build/cpu.bin</code>.</p> <p>This includes the DSP firmware, which is sent to the Blackfin by the CPU, via SPI.</p> <p>I will add documentation for setting up the build environment locally, but you can probably work it out from the commands in the Dockerfile.</p>"},{"location":"building/#makefile-options","title":"Makefile Options","text":""},{"location":"cpu-architecture/","title":"CPU Firmware","text":"<p><code>freetribe/cpu/src</code></p> <p>The CPU firmware controls the full system, initialising the other hardware, processing user input and providing feedback. The firmware is split into kernel and user tasks. The separation is currently in name only, memory protection is not yet supported.</p>"},{"location":"cpu-architecture/#kernel","title":"Kernel","text":"<p><code>freetribe/cpu/src/kernel/knl_*</code></p> <p>The kernel orchestrates a set of services, built on device and peripheral drivers. A simple API is provided, hiding the complexity of the underlying system. The rest of this section looks at each layer, from the hardware up.</p>"},{"location":"cpu-architecture/#hardware","title":"Hardware","text":"<p><code>freetribe/cpu/src/kernel/hardware/hw_*</code></p> <p>Macros and definitions for accessing CPU registers. These files are from Texas Instruments Starterware. We should not have to modify anything at this layer.</p>"},{"location":"cpu-architecture/#hal","title":"HAL","text":"<p><code>freetribe/cpu/src/kernel/hal/hal_*</code></p> <p>Functions for accessing CPU registers. These files are from Texas Instruments Starterware. It is unlikely that we will need to modify anything at this layer.</p>"},{"location":"cpu-architecture/#peripheral","title":"Peripheral","text":"<p><code>freetribe/cpu/src/kernel/peripheral/per_*</code></p> <p>The peripheral layer uses HAL functions to initialise and control CPU peripherals, such as UART or SPI. Interrupt Service Routines may execute callback handlers, registered by the layer above. Peripheral drivers should be self-contained and deal with a single peripheral. An exception may be DMA transfers, which are currently unsupported.</p>"},{"location":"cpu-architecture/#device","title":"Device","text":"<p><code>freetribe/cpu/src/kernel/device/dev_*</code></p> <p>The device layer uses peripheral drivers to provide access to system devices, such as flash memory or the LCD. Device drivers may use multiple peripheral drivers, for example, using SPI to control the LCD and GPIO to control the backlight.</p>"},{"location":"cpu-architecture/#service","title":"Service","text":"<p><code>freetribe/cpu/src/kernel/service/svc_*</code></p> <p>The service layer uses device drivers to provide services to the kernel. Examples include MIDI processing and handling the control panel. Services are implemented as non-blocking state machines and should do as little as possible each time they are invoked.</p>"},{"location":"cpu-architecture/#api","title":"API","text":"<p><code>freetribe/cpu/src/kernel/api/ft_*</code></p> <p>The API layer provides an interface to everything needed by user code. Function names should be human friendly, with reduced sets of arguments where possible.</p>"},{"location":"cpu-architecture/#user","title":"User","text":"<p><code>freetribe/cpu/src/user/usr_*</code></p> <p>The user task runs any code provided as an app. There are 2 functions we override, <code>app_init()</code> and <code>app_run()</code>, see Getting Started for more.</p>"},{"location":"cpu-architecture/#app","title":"App","text":"<p><code>freetribe/cpu/src/apps/*</code></p> <p>Apps are whatever we make them. We override the <code>app_init()</code> and <code>app_run()</code> functions from the user task and call functions from the API. Apps that process audio must have a corresponding module in the DSP firmware.</p> <p>See the Freetribe Tutorial for more.</p>"},{"location":"debugging/","title":"Attaching a Debugger","text":"<p>See the Hacktribe Debrick Guide for more details on getting a debugger attached.</p>"},{"location":"debugging/#cpu","title":"CPU","text":"<p>For the CPU, a JLink EDU and JLinkGDBServer works well. We can also use a Raspberry Pi and OpenOCD.</p> <p>If using JLink, connect the debugger to USB host, then power electribe using modified power switch. Then run:</p> <pre><code>JLinkGDBServer -device am1802 -speed 0\n</code></pre> <p>If using Raspberry Pi, OpenOCD will exit if the electribe is not powered, but the electribe will boot if OpenOCD is not attached, so we need some trickery. First power up electribe, then run OpenOCD, then power off electribe with OpenOCD still running. Then power up electribe again before restarting OpenOCD. It is a lot easier to use a JLink.</p> <p>Once you have a gdb server attached to the CPU, change directory to <code>freetribe/cpu</code> and run:</p> <pre><code>arm-none-eabi-gdb\n</code></pre> <p>The commands in <code>freetribe/cpu/.gdbinit</code> should connect to the gdb server, load the symbols from <code>cpu/build/cpu.elf</code> and run the firmware. You may need to edit the port number in <code>.gdbinit</code>. OpenOCD uses <code>3333</code> by default, with JLinkGDBServer using <code>2331</code>.</p> <p>If all is well, you should hit a breakpoint at <code>main</code>. Other useful breakpoints may be <code>knl_init</code>, <code>knl_run</code>, <code>app_init</code> and <code>app_run</code>.</p>"},{"location":"debugging/#dsp","title":"DSP","text":"<p>For the DSP, I've only managed to get the official debugger from Analog Devices working. The ADSP-ICE-1000 costs around \u00a3180 (thank you sponsors) and is very much a one-trick pony. I will try again to get the Raspberry Pi set up with the DSP, but I'm not sure if the Analog Devices OpenOCD fork is even supposed to support this.</p> <p>The good news is, the DSP firmware is loaded by the CPU. So if you can deal without debugging you can still load and run your code.</p> <p>If you have a debugger for the DSP, first run the binary on the CPU. By the time the CPU reaches <code>app_run</code> the DSP kernel will be running.</p> <p>Change directory to <code>freetribe/dsp</code> and run:</p> <pre><code>sudo openocd-bfin -s /usr/share/openocd-bfin/scripts \\\n                  -f /usr/share/openocd-bfin/scripts/interface/ice1000.cfg \\\n                  -f /usr/share/openocd-bfin/scripts/target/bf527.cfg\n</code></pre> <p>Then in another shell in the same directory:</p> <pre><code>bfin-elf-gdb\n</code></pre> <p>The commands in <code>freetribe/dsp/.gdbinit</code> should connect to the gdb server, load the symbols from <code>freetribe/dsp/build/bfin.elf</code> and set a breakpoint at <code>module_process</code>, the audio processing callback.</p> <p>I will try to add new sysex functions to Hacktribe, so we can load and execute code without needing a debugger.</p>"},{"location":"dsp-architecture/","title":"DSP Firmware","text":"<p>The DSP kernel receives commands from the CPU and processes audio frames. A user defined module runs in the audio callback, with an interface similar to many plugin formats. The code here is less developed, but will gradually be made more similar to the CPU firmware.</p>"},{"location":"dsp-architecture/#kernel","title":"Kernel","text":"<p><code>freetribe/dsp/src/kernel/knl_*</code></p> <p>Similar to the CPU firmware, the kernel should orchestrate a set of services, built on device and peripheral drivers. The rest of this section looks at each layer, from the hardware up.</p>"},{"location":"dsp-architecture/#peripheral","title":"Peripheral","text":"<p><code>freetribe/dsp/src/kernel/peripheral/per_*</code></p> <p>The peripheral layer accesses hardware registers directly to initialise and control DSP peripherals, such as SPI or SPORT (for i2s). Currently, Interrupt Service Routines push directly to queues in the peripheral driver. Queues should be moved up to a device layer, with ISRs executing optional callback functions. Peripheral drivers should be self-contained and deal with a single peripheral and its associated DMA channels.</p>"},{"location":"dsp-architecture/#device","title":"Device","text":"<p><code>freetribe/dsp/src/kernel/device/dev_*</code></p> <p>The device layer does not currently exist. This is where we should handle peripheral interrupts, pushing data to queues and providing access for the service layer above.</p>"},{"location":"dsp-architecture/#service","title":"Service","text":"<p><code>freetribe/dsp/src/kernel/service/svc_*</code></p> <p>The service layer uses drivers to provide services to the kernel. For example, the CPU command service parses and handles messages received from the CPU via SPI. Services are implemented as non-blocking state machines and should do as little as possible each time they are invoked.</p>"},{"location":"dsp-architecture/#module","title":"Module","text":"<p><code>freetribe/dsp/src/modules/*</code></p> <p>Modules are whatever we make them. We override functions to provide initialisation, audio processing, and parameter change handling. The <code>module_process()</code> function is called for each audio sample, block processing is not yet supported. The <code>module_set_param()</code> function is called by the CPU command service when the appropriate message is received.</p> <p>What's currently called 'module' will be refactored into an 'app', similar to the CPU firmware. An app could host a set of modules, providing a patchable virtual modular system.</p> <p>See the Freetribe Tutorial for more.</p>"},{"location":"examples/","title":"Examples","text":"<p>The main demo uses the volume knob to control attenuation of audio pass-through, while sending MIDI CC and printing to the display. Recevied MIDI note messages are echoed to the output and an LED blinks at regular intervals. An external library is integrated for GUI management.</p> <p>Future examples will deal separately with individual features, building up to a more complex application.</p>"},{"location":"features/","title":"Features","text":"<p>From a user application perspective, Freetribe is currently light on features. Most of the hardware initialisation is complete, with driver stacks for much of the system. Built on this is a set of services providing a high-level interface to the device. Some basic examples are provided, showing how to integrate user application code with the Freetribe kernel.</p>"},{"location":"features/#existing-features","title":"Existing Features","text":"<ul> <li>Serial MIDI input and output via TRS port.</li> <li>Set or clear a pixel anywhere in the vast 128x64 dot-matrix.</li> <li>Control backlight RGB (binary).</li> <li>Register callbacks for all of the panel controls.</li> <li>Set and toggle LEDs, with brightness control for those with support.</li> <li>Send commands to the Blackfin DSP and receive feedback.</li> <li>Process audio based on control input.</li> <li>Audio module API similar to many plugin formats.</li> </ul>"},{"location":"features/#planned-features","title":"Planned Features","text":"<p>Some of these are in progress, most should be possible.</p> <ul> <li>High speed DSP control via EMIFA/HostDMA.</li> <li>DMA support for peripheral drivers.</li> <li>USB driver.</li> <li>SD card driver.</li> <li>DSP block processing.</li> <li>Memory protection.</li> <li>Dynamic loading of apps and modules.</li> <li>Preemptive scheduling using FreeRTOS.</li> <li>Embedded Lua and MicroPython.</li> <li>Support for sync ports.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section shows how to get started with the Freetribe API. The minimal example code shows how to blink an LED on the panel using the Freetribe API's non-blocking delay function.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before we can actually run our app, we will need to install the toolchain and attach a debugger. For now, we can work in a codespace on Github, and continue with this section to get an idea of how the Freetribe API works.</p> <p>Create a codespace on the <code>main</code> branch of the Freetribe Github repo, then create a directory for the app and a file for the code:</p> <pre><code>mkdir cpu/src/apps/blink\ntouch cpu/src/apps/blink.c\n</code></pre> <p>Open <code>blink.c</code> in the editor of your choice. The codespace includes VSCode and neovim.</p>"},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<p>First, we must include the Freetribe API:</p> <pre><code>#include \"freetribe.h\"\n</code></pre> <p>This gives us access to all the functions our application should need for interacting with the device.</p> <p>Next, there are 2 functions we should override. The first, <code>app_init()</code>, runs once when our app starts. This is a good place to register callbacks for events we are interested in, and do any initialisation required by external libraries.</p> <p>In this example, we initialise a static global variable to hold the start time of our delay. The <code>app_init()</code> function takes no arguments and returns <code>t_status</code>, an integer error code.</p> <pre><code>// 1 second in microseconds.\n#define DELAY_TIME 1000000\n\nstatic uint32_t g_start_time;\n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n</code></pre> <p></p> <p>The second function, <code>app_run()</code>, is called continuously in the main loop, after <code>app_init()</code> has completed. In this example, we toggle an LED on the panel if 1 second has passed, and reset the delay start time.</p> <p>The <code>app_run</code> function takes no arguments and returns nothing.</p> <pre><code>void app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre> <p>This is all the code we need to blink an LED at regular intervels, everything else is taken care of by the Freetribe kernel. It is important that any code we write is non-blocking, as everything is running in the same loop as the kernel. The full listing of <code>blink.c</code> is reproduced at the bottom of this page.</p>"},{"location":"getting-started/#building","title":"Building","text":"<p>Build with <code>make</code>, passing the name of our app directory in the APP environment variable:</p> <pre><code>make clean &amp;&amp; make APP=blink\n</code></pre> <p>There will be a lot of warnings about incompatible types and implicit declarations, but there should be no errors. See Building an Application for more information about the build system.</p>"},{"location":"getting-started/#output-files","title":"Output Files","text":"<p>The final output file, <code>freetribe/cpu/build/cpu.elf</code>, includes the CPU kernel and our app. It also includes the DSP kernel and audio processing module, as an array sent to the DSP during boot. We will explore the other files in this directory in future tutorials.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Once you have set up the toolchain, move on to attaching a debugger to see how to run this simple example app. After that, work through the Freetribe Tutorial to explore more of the Freetribe API.</p>"},{"location":"getting-started/#blinkc","title":"<code>blink.c</code>","text":"<pre><code>// Freetribe: Minimal Example\n// License: AGPL-3.0-or-later\n\n#include \"freetribe.h\"\n\n// 1 second in microseconds.\n#define DELAY_TIME 1000000\n\nstatic uint32_t g_start_time;\n\nt_status app_init(void) {\n\n    // Set start time.\n    g_start_time = ft_get_delay_current();\n\n    return SUCCESS;\n}\n\nvoid app_run(void) {\n\n    // Wait for delay.\n    if (ft_delay(g_start_time, DELAY_TIME)) {\n\n        // Toggle LED.\n        ft_toggle_led(LED_TAP);\n\n        // Reset start time.\n        g_start_time = ft_get_delay_current();\n\n    }\n}\n</code></pre>"},{"location":"license/","title":"License","text":"<p>AGPL-3.0-or-later.</p>"},{"location":"support/","title":"Support","text":""},{"location":"support/#support-for-you","title":"Support for You","text":"<p>If you need help with this project, please visit the  Freetribe discussion forum  on Github.</p>"},{"location":"support/#support-for-me","title":"Support for Me","text":"<p>Freetribe is free (as in GPL) and always will be. If you would like to support my work you are most welcome to  become a sponsor. Freetribe exists because people sponsored Hacktribe. Your support helps keep me motivated, fuelled and focussed.</p>"},{"location":"toolchain/","title":"Installing the Toolchain","text":"<p>This section describes how to install the toolchain for building and debuggong Freetribe applications. See Building an Application for more details on the build system, and Attaching a Debugger for how to run and debug an application.</p>"},{"location":"toolchain/#installing-locally","title":"Installing Locally","text":""},{"location":"toolchain/#installing-with-docker","title":"Installing with Docker","text":"<p>If you have <code>docker compose</code> installed on your local machine, change to the <code>freetribe</code> directory and build the docker image:</p> <pre><code>docker compose build\n</code></pre> <p>Then start a container:</p> <pre><code>docker compose up -d\n</code></pre> <p>The current working directory will be mounted in the container at <code>/freetribe</code>.</p>"},{"location":"tutorial/","title":"Freetribe Tutorial","text":"<p>Visit the Freetribe Tutorial  for a series of  examples demonstrating features of the Freetribe API. Each example builds on the last, moving from a simple blinking LED,  to a more complex application with user input, audio processing, MIDI handling and feedback to the display.</p>"}]}